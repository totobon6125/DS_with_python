<list>
사람 = [Alex, 990102, M]
0번째는 이름, 1번쨰는 출생일, 2번째는 성별 로 구분
하지만 배열의 크기가 커질 수록 비효율이 발생

<dictionary>
key 와 value 로 구분되는 구조
{name: "Alex", birth: 990102, "M"}
list와 다르게 해쉬 자료 구조로 탐색과 조회가 list에 비해서 빠름 => O(1) 속도
다만, 공간 복잡도에선 단점이 있음.(복잡함)

선언1
a = {'name':'alex'}

선언2
a = {}
a['name'] = 'alex'
=> a = {'name':'alex'}

선언3
a = dict()

# 주의!!
없는 키를 선언할 경우 에러가 발생

# 키 에러 없이 dictionary 만드는 법
import collection form dictionary 를 선언하여 외부 모듈을 가져옴.

-----------------------------------------------------------------
<set>
- {} 로 선언함  => a = {} set인가 dictionary인가?
- 중복된 값을 넣으면 자동으로 제거함.
- 해쉬 자료 구조. => 검색 속도가 빠름 => O(1)

-----------------------------------------------------------------
<튜플>
- 상수 값, 고정 값.
- 변할 필요가 없는 값

------------------------------------------------------------------
<range>
- range(시작점, 끝나는점(포함X), 스텝)
- 함수 -> 연속된 정수형을 만들어주는 함수
- ex
    a = [1,2,3,4,5]

    for i in a:
        print(a)
    
    for i in range(2):
        a[i] += 1
        print(a)

------------------------------------------------------------------
<문자열>
- 컨테이너
- 문자열은 각각을 선택 할 순 있지만 수정을 할 순 없음.

------------------------------------------------------------------
<brute force(=완전탐색)>
- 가능한 모든 경우의 수를 모두 탐색하는 것.
- 알고리즘의 마지막에 통과를 못하는 이유 중 edge case 를 충족시키지 못하기 때문.
- 알고리즘의 시작.
- 반복문을 통해 구현.

------------------------------------------------------------------
<반복문>
- for
    컨테이너 자료형에서 원소들을 하나씩 뽑아오는 역할. 마지막 원소를 뽑아오면 반복문이 종료됨.
= 형태
    for 변수 in 컨테이너 :
        검토 과정

- while
